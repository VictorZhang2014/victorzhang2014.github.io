<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  
  <title>iOS中的锁</title>
  <meta name="author" content="Victor Zhang">
  <meta name="description" content="iOS,逆向工程,AI,.NET">
  
  
  <meta property="og:title" content="iOS中的锁"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="Simple, but perfect"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="Simple, but perfect" type="application/atom+xml">
  <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="behind">
      <a href="/" class="back black-color">
        <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M2 30 L30 2 M30 30 L2 2"></path>
        </svg>
      </a>
      <div class="description">
        &nbsp;What will you do if you weren't afraid ? 
      </div>
    </div>
    <div class="container">
      

  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        iOS中的锁
    </h1>
  


    </div>
    <div class="meta center">
      
<time datetime="2017-10-15T09:30:34.000Z">
<svg class="i-calendar" viewBox="0 0 32 32" width="14" height="14" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2017-10-15
</time>



    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="14" height="14" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/categories/iOS/">iOS</a>




    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="14" height="14" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/tags/NSLock-NSCondition-NSRecursiveLock-NSConditionLock-pthread-mutex-dispatch-semaphore/">NSLock, NSCondition, NSRecursiveLock, NSConditionLock, pthread_mutex, dispatch_semaphore</a>


    </div>
    <hr>
    <div class="picture-container">
      
    </div>
    <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<code>多线程编程</code>中，并发会使<code>一段代码</code>在<code>同一段时间</code>内线程之间互相<code>争抢资源</code>（<code>资源共享</code>）而产生<code>数据</code>的<code>不一致性</code>，为了<code>解决</code>这个问题，就<code>引入</code>了<code>锁</code>。锁的类型有多种，在iOS中，有如下：</p>
<ul>
<li>1.OSSpinLock    自旋锁</li>
<li>2.dispatch_semaphore    GCD信号量实现加锁</li>
<li>3.pthread_mutex    互斥锁</li>
<li>4.NSLock  互斥锁</li>
<li>5.NSCondition    信号锁</li>
<li>6.pthread_mutex(recursive)  递归互斥锁</li>
<li>7.NSRecursiveLock  递归锁</li>
<li>8.NSConditionLock  条件锁</li>
<li>9.@synchronized  互斥锁</li>
</ul>
<p>在看本篇文章前，请先了解<a href="/2017/10/15/GCD的一般认知/"><code>GCD</code></a>和<a href="/2017/10/15/NSOperation的认知/"><code>NSOperation</code></a>, 如果你已熟知，请继续往下看。</p>
<p>我们先来看下iOS中全部的锁，以及它们的效率<br><img src="/img/iOS/lock/iOS_lock_summary_benchmark.png" alt="iOS 中全部的锁"></p>
<p>这个简单的性能测试是在iPhone 6, iOS 9上跑的，<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">测试者在这篇文章</a><br>该结果显示的，横向柱状条最短的为性能最佳和最高；可知，OSSpinLock最佳，但是OSSpinLock被发现bug，Apple工程师透露了这个自旋锁有问题，暂时停用了，<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">查看这里</a><br>虽然OSSpinLock（自旋锁）有问题，但是我们还是看到了<code>pthread_mutex</code>和<code>dispatch_semaphore</code>性能排行仍是很高，而且苹果在新系统中也已经优化了<br>这两个锁的性能，所以我们在开发时也可以使用它们啦。</p>
<p>下面来一一介绍它们的使用</p>
<p><br></p>
<h2 id="1-dispatch-semaphore-GCD信号量实现加锁"><a href="#1-dispatch-semaphore-GCD信号量实现加锁" class="headerlink" title="1.dispatch_semaphore    GCD信号量实现加锁"></a>1.dispatch_semaphore    GCD信号量实现加锁</h2><p>GCD中提供了一种<code>信号机制</code>，也是为了<code>解决</code>资源<code>抢占问题</code>的，支持<code>信号通知</code>和<code>信号等待</code>。</p>
<ul>
<li>1.每当<code>发送</code>一个<code>信号</code>时，则<code>信号量加1</code></li>
<li>2.每当<code>发送</code>一个<code>等待信号</code>时，则<code>信号量减1</code></li>
<li>3.如果<code>信号量为0</code>，则信号会处于<code>等待状态</code>，直到信号量<code>大于0</code>时就开始执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)example &#123;</span><br><span class="line"></span><br><span class="line">    //假设一共电影票3张票</span><br><span class="line">    self.movieTickets = 3;</span><br><span class="line">    </span><br><span class="line">    //创建信号量</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line">    </span><br><span class="line">    //添加任务1</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 taskName:@&quot;任务1&quot; semaphore:semaphore];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //添加任务2</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 taskName:@&quot;任务2&quot; semaphore:semaphore];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)buyTicketWithCounts:(int)counts taskName:(NSString *)taskName semaphore:(dispatch_semaphore_t)semaphore &#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    for (int i = 0; i &lt; counts; i++) &#123;</span><br><span class="line">        if (self.movieTickets == 0) &#123;</span><br><span class="line">            NSLog(@&quot;%@ 票已卖完! %@&quot;, taskName, [NSThread currentThread]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@ 抢到%d票 剩余%d张票 %@&quot;, taskName, i + 1, --self.movieTickets, [NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[23790:1042584] 任务1 抢到1票 剩余2张票 &lt;NSThread: 0x604000465180&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[23790:1042584] 任务1 抢到2票 剩余1张票 &lt;NSThread: 0x604000465180&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[23790:1042582] 任务2 抢到1票 剩余0张票 &lt;NSThread: 0x604000464e00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[23790:1042582] 任务2 票已卖完! &lt;NSThread: 0x604000464e00&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="2-pthread-mutex-互斥锁"><a href="#2-pthread-mutex-互斥锁" class="headerlink" title="2.pthread_mutex    互斥锁"></a>2.pthread_mutex    互斥锁</h2><p>在POSIX（可移植操作系统）中，<code>pthread_mutex</code>是一套用于多线程同步的mutex锁，如同名一样，使用起来非常简单，性能比较高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> //初始化互斥锁</span><br><span class="line">__block pthread_mutex_t _mutex;</span><br><span class="line">pthread_mutex_init(&amp;_mutex, NULL);</span><br><span class="line"></span><br><span class="line">//创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">//创建并行队列</span><br><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;my.concurrent.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">//添加任务A到队列组</span><br><span class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    NSLog(@&quot;NSBlockOperation A %@&quot;, [NSThread currentThread]);</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//添加任务B到队列组</span><br><span class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    NSLog(@&quot;NSBlockOperation B %@&quot;, [NSThread currentThread]);</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//任务执行完，接收到通知</span><br><span class="line">dispatch_group_notify(group, concurrentQueue, ^&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    NSLog(@&quot;pthread_mutex_t has been destroyed!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[22982:1011384] NSBlockOperation B &lt;NSThread: 0x60000026a380&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[22982:1011382] NSBlockOperation A &lt;NSThread: 0x604000465ac0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[22982:1011382] pthread_mutex_t has been destroyed!</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="3-NSLock-互斥锁"><a href="#3-NSLock-互斥锁" class="headerlink" title="3.NSLock  互斥锁"></a>3.NSLock  互斥锁</h2><p>在Cocoa中<code>NSLock</code>是一种简单的互斥锁，继承自<code>NSLocking</code>协议，定义了<code>lock</code>和<code>unlock</code>方法，<br>而<code>NSLock</code>类还增加了<code>tryLock</code>和<code>lockBeforeDate:</code>方法。</p>
<ul>
<li>1.<code>tryLock</code>方式试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程，相反它只会返回NO</li>
<li>2.<code>lockBeforeDate:</code>方法试图获取一个锁，但是如果锁没有在规定的时间内被获得，它会从阻塞状态变为非阻塞状态，返回NO</li>
<li>3.使用时，注意<code>lock</code>和<code>unlock</code>是成对出现的，也就说<code>lock</code>方法连续不能调用多次</li>
</ul>
<p>我们这里来个简单的题：<br>假设一共有5张电影票，<br>现在有三个人去买票，每人要购买2张，<br>也就是三个人一共要买6张票，可是总电影票数只有5张，<br>所以最终他们有一人只能买到一张票<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)example &#123;</span><br><span class="line">    //创建锁的对象</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line">    </span><br><span class="line">    //假设总共有5张电影票</span><br><span class="line">    self.movieTickets = 5;</span><br><span class="line">    </span><br><span class="line">    //创建一个并行队列</span><br><span class="line">    dispatch_queue_t myconcurrent = dispatch_queue_create(&quot;com.concurrent.queue.hello&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    //A线程异步并行 买2张票</span><br><span class="line">    dispatch_async(myconcurrent, ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 thread:@&quot;线程A&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //B线程异步并行 买2张票</span><br><span class="line">    dispatch_async(myconcurrent, ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 thread:@&quot;线程B&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //C线程异步并行 买2张票</span><br><span class="line">    dispatch_async(myconcurrent, ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 thread:@&quot;线程C&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)buyTicketWithCounts:(int)counts thread:(NSString *)threadName &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    for (int i = 1; i &lt;= counts; i++) &#123;</span><br><span class="line">        if (self.movieTickets == 0) &#123;</span><br><span class="line">            NSLog(@&quot;票卖完了 %@&quot;, threadName);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;剩余票数：%d  %@ %@&quot;, self.movieTickets, threadName, [NSThread currentThread]);</span><br><span class="line">        self.movieTickets--;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[20232:919739] 剩余票数：5  线程A &lt;NSThread: 0x600000468240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[20232:919739] 剩余票数：4  线程A &lt;NSThread: 0x600000468240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[20232:919738] 剩余票数：3  线程B &lt;NSThread: 0x60000007fa40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[20232:919738] 剩余票数：2  线程B &lt;NSThread: 0x60000007fa40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[20232:919745] 剩余票数：1  线程C &lt;NSThread: 0x6040004674c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-10-16 test[20232:919745] 票卖完了 线程C</span><br></pre></td></tr></table></figure></p>
<p>保证了总票数5张没有变，最终有一个人只能买到一张票</p>
<p><br></p>
<h2 id="4-NSCondition-信号锁"><a href="#4-NSCondition-信号锁" class="headerlink" title="4.NSCondition    信号锁"></a>4.NSCondition    信号锁</h2><p><code>NSCondition</code>也是派生自<code>NSLocking</code>, 所以它就有<code>lock</code>和<code>unlock</code>方法，但是<code>NSCondition</code>本身还有<code>wait</code>和<code>signal</code>方法，非常好用。<br>我们拿生产者消费者模式来举例吧</p>
<ul>
<li>1.消费者获取锁，取产品，如果没有取到，则<code>wait</code>，这时会释放锁，知道有线程唤醒它去消费产品</li>
<li>2.生产者制造产品，首先也要取得锁，然后生产，再发<code>signal</code>，这样就可以唤醒正在<code>wait</code>的线程的消费者</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)ProducerConsumerPattern &#123;</span><br><span class="line">    self.products = [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    //创建信号量锁</span><br><span class="line">    NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line">    </span><br><span class="line">    //创建一个并行队列</span><br><span class="line">    NSOperationQueue *myQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    </span><br><span class="line">    //消费者</span><br><span class="line">    NSBlockOperation *consumer = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        while (self.products.count == 0) &#123;</span><br><span class="line">            [condition wait]; //阻塞住，让线程等待，直到被通知到</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;Consumed a product which named %@ %@&quot;, self.products.firstObject, [NSThread currentThread]);</span><br><span class="line">        [condition unlock];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //生产者</span><br><span class="line">    NSBlockOperation *producer = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        </span><br><span class="line">        NSString *productName = [NSString stringWithFormat:@&quot;产品-%ld&quot;, random()];</span><br><span class="line">        NSLog(@&quot;Produced a product %@ %@ &quot;, productName, [NSThread currentThread]);</span><br><span class="line">        [self.products addObject:productName];</span><br><span class="line">        </span><br><span class="line">        [condition signal];</span><br><span class="line">        [condition unlock];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [myQueue addOperation:producer];</span><br><span class="line">    [myQueue addOperation:consumer];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[24877:1088668] Produced a product 产品-1804289383 &lt;NSThread: 0x600000269a00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[24877:1088667] Consumed a product which named 产品-1804289383 &lt;NSThread: 0x604000278700&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="5-pthread-mutex-recursive-递归互斥锁"><a href="#5-pthread-mutex-recursive-递归互斥锁" class="headerlink" title="5.pthread_mutex(recursive)  递归互斥锁"></a>5.pthread_mutex(recursive)  递归互斥锁</h2><p>其实就是一个参数来断定<code>pthread_mutex_t</code>是否是递归锁，<br>我们先来看下死锁的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)pthread_recursive_lock &#123;</span><br><span class="line">    __block pthread_mutex_t _mutext;</span><br><span class="line">    pthread_mutex_init(&amp;_mutext, NULL);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        static void (^MyBlock)(int);</span><br><span class="line">        MyBlock = ^(int value)&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;_mutext); //第二次运行到这里会阻塞住，产生死锁，因为之前被锁住的资源还未解锁，所以就造成它们俩互相等待</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">                NSLog(@&quot;value = %d %@&quot;, value, [NSThread currentThread]);</span><br><span class="line">                MyBlock(value - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        MyBlock(5);</span><br><span class="line">        pthread_mutex_unlock(&amp;_mutext);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解决这个死锁的重点就是给pthread_mutex_t设置属性为递归锁，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)pthread_recursive_lock &#123;</span><br><span class="line"></span><br><span class="line">    //创建互斥锁的属性对象，并设置递归锁</span><br><span class="line">    pthread_mutexattr_t _mutexattr;</span><br><span class="line">    pthread_mutexattr_init(&amp;_mutexattr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;_mutexattr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    </span><br><span class="line">    //创建互斥锁对象</span><br><span class="line">    __block pthread_mutex_t _mutext;</span><br><span class="line">    pthread_mutex_init(&amp;_mutext, &amp;_mutexattr);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        static void (^MyBlock)(int);</span><br><span class="line">        MyBlock = ^(int value)&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;_mutext); //第二次运行到这里会产生死锁，因为之前被锁住的资源还未解锁，所以就造成它们俩互相等待</span><br><span class="line">            if (value &gt; 0) &#123;</span><br><span class="line">                NSLog(@&quot;value = %d %@&quot;, value, [NSThread currentThread]);</span><br><span class="line">                MyBlock(value - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        MyBlock(5);</span><br><span class="line">        pthread_mutex_unlock(&amp;_mutext);</span><br><span class="line">        pthread_mutex_destroy(&amp;_mutext);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[25369:1103912] value = 5 &lt;NSThread: 0x600000464a00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[25369:1103912] value = 4 &lt;NSThread: 0x600000464a00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[25369:1103912] value = 3 &lt;NSThread: 0x600000464a00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[25369:1103912] value = 2 &lt;NSThread: 0x600000464a00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[25369:1103912] value = 1 &lt;NSThread: 0x600000464a00&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="6-NSRecursiveLock-递归锁"><a href="#6-NSRecursiveLock-递归锁" class="headerlink" title="6.NSRecursiveLock  递归锁"></a>6.NSRecursiveLock  递归锁</h2><p><code>NSRecursiveLock</code>是一个递归锁，它的<code>lock</code>方法可以被同一个线程多次请求，而且不会引起死锁；<br>主要用在循环或者递归操作中，多次<code>lock</code>，只需要一次<code>unlock</code>，因为递归锁内部会有一个跟踪被<code>lock</code>的数次的功能，<br>不管被<code>lock</code>多少次，最后<code>unlock</code>也会把所有的持有资源给解锁，来看一个经典的死锁案例，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSLock *lock_i = [[NSLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    static void (^MyBlock)(int);</span><br><span class="line">    MyBlock = ^(int value) &#123;</span><br><span class="line">        [lock_i lock]; //加锁代码在递归执行第二次时阻塞了，也就是死锁了</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            NSLog(@&quot;value = %d %@&quot;, value, [NSThread currentThread]);</span><br><span class="line">            sleep(2);</span><br><span class="line">            MyBlock(value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        [lock_i unlock];</span><br><span class="line">    &#125;;</span><br><span class="line">    MyBlock(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>看看这个代码，由于在递归运行过程中，<code>[lock_i lock];</code>会被多次调用，而<code>NSLock</code>每次<code>lock</code>对象时，必须是<code>unlock</code>状态，<br>所以它就会一直等着上一个<code>lock</code>的对象资源被<code>unlock</code>掉，但是上一个并没有执行<code>unlock</code>，所以就造成了他们之间互相等待，而形成死锁。<br>为了解决这个问题，我们就需要使用递归锁<code>NSRecursiveLock</code>，因为递归锁可以多次<code>lock</code>，最后一次<code>unlock</code>就能解锁所有已经被<code>lock</code>的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    static void (^MyBlock)(int);</span><br><span class="line">    MyBlock = ^(int value) &#123;</span><br><span class="line">        [lock lock]; //这行代码加锁执行了多次</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line">            NSLog(@&quot;value = %d %@&quot;, value, [NSThread currentThread]);</span><br><span class="line">            sleep(2);</span><br><span class="line">            MyBlock(value - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];//解锁只执行了一次</span><br><span class="line">    &#125;;</span><br><span class="line">    MyBlock(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[21404:957416] value = 5 &lt;NSThread: 0x604000073280&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[21404:957416] value = 4 &lt;NSThread: 0x604000073280&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[21404:957416] value = 3 &lt;NSThread: 0x604000073280&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[21404:957416] value = 2 &lt;NSThread: 0x604000073280&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[21404:957416] value = 1 &lt;NSThread: 0x604000073280&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="7-NSConditionLock-条件锁"><a href="#7-NSConditionLock-条件锁" class="headerlink" title="7.NSConditionLock  条件锁"></a>7.NSConditionLock  条件锁</h2><p><code>NSConditionLock</code>定义了一组可以指定<code>int类型</code>条件的互斥锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSConditionLock *conditionLock = [[NSConditionLock alloc] initWithCondition:0];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    for (int i = 0; i &lt;= 3; i++) &#123;</span><br><span class="line">        [conditionLock lock];</span><br><span class="line">        NSLog(@&quot;A %d %@&quot;, i, [NSThread currentThread]);</span><br><span class="line">        sleep(1);</span><br><span class="line">        [conditionLock unlockWithCondition:i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">    [conditionLock lock];</span><br><span class="line">    NSLog(@&quot;B %@&quot;,[NSThread currentThread]);</span><br><span class="line">    [conditionLock unlock];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="8-synchronized-互斥锁"><a href="#8-synchronized-互斥锁" class="headerlink" title="8.@synchronized  互斥锁"></a>8.@synchronized  互斥锁</h2><p>我们这里来个简单的题：<br>假设一共有5张电影票，<br>现在有三个人去买票，每人要购买2张，<br>也就是三个人一共要买6张票，可是总电影票数只有5张，<br>所以最终他们有一人只能买到一张票</p>
<p><code>@synchronized</code>关键字加锁，是一种互斥锁，性能较差不推荐使用；看代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)example &#123;</span><br><span class="line">    //假设总共有5张电影票</span><br><span class="line">    self.movieTickets = 5;</span><br><span class="line">    </span><br><span class="line">    //创建一个并行队列</span><br><span class="line">    dispatch_queue_t myconcurrent = dispatch_queue_create(&quot;com.concurrent.queue.hello&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    //A线程异步并行 买2张票</span><br><span class="line">    dispatch_async(myconcurrent, ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 thread:@&quot;线程A&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //B线程异步并行 买2张票</span><br><span class="line">    dispatch_async(myconcurrent, ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 thread:@&quot;线程B&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //C线程异步并行 买2张票</span><br><span class="line">    dispatch_async(myconcurrent, ^&#123;</span><br><span class="line">        [self buyTicketWithCounts:2 thread:@&quot;线程C&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)buyTicketWithCounts:(int)counts thread:(NSString *)threadName &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= counts; i++) &#123;</span><br><span class="line">            if (self.movieTickets == 0) &#123;</span><br><span class="line">                NSLog(@&quot;票卖完了 %@&quot;, threadName);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            NSLog(@&quot;剩余票数：%d  %@ %@&quot;, self.movieTickets, threadName, [NSThread currentThread]);</span><br><span class="line">            self.movieTickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>猜猜输出结果会是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[19868:910931] 剩余票数：5  线程A &lt;NSThread: 0x600000270400&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19868:910931] 剩余票数：4  线程A &lt;NSThread: 0x600000270400&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19868:910928] 剩余票数：3  线程B &lt;NSThread: 0x600000270640&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19868:910928] 剩余票数：2  线程B &lt;NSThread: 0x600000270640&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19868:910930] 剩余票数：1  线程C &lt;NSThread: 0x6000002705c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19868:910930] 票卖完了 线程C</span><br></pre></td></tr></table></figure></p>
<p>这里例子说明，总票数5张没有变，因为使用了<code>@synchronized</code>互斥锁；假设此时，我们不用<code>@synchronized</code>，会输出什么结果了？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-10-16 test[19984:914005] 剩余票数：5  线程A &lt;NSThread: 0x604000067c40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19984:914004] 剩余票数：5  线程C &lt;NSThread: 0x600000276180&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19984:914007] 剩余票数：5  线程B &lt;NSThread: 0x60400026c880&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19984:914005] 剩余票数：4  线程A &lt;NSThread: 0x604000067c40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19984:914004] 剩余票数：3  线程C &lt;NSThread: 0x600000276180&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-10-16 test[19984:914007] 剩余票数：2  线程B &lt;NSThread: 0x60400026c880&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到没，卖出了6张票😰</p>
<p><br><br><br><br><a href="/2017/10/15/GCD的一般认知/">GCD的一般认知，打开</a><br><a href="/2017/10/15/NSOperation的认知/">NSOperation的认知，打开</a><br><a href="/2017/10/15/NSThread的认知/">NSThread的认知</a><br><a href="/2017/10/15/iOS的Runloop认知/">iOS的Runloop认知，打开</a></p>


  </article>
  </script>
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <div class="busuanzi center">
    页阅读量:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    站访问量:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    站访客数:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>




    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot container">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © Victor Zhang 2014-2018
    </div>
    <div class="secondrow">
        <a href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
